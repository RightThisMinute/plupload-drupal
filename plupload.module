<?php

/**
 * @file
 * Implementation of plupload.module.
 */

/**
 * Implements hook_element_info().
 */
function plupload_element_info() {
  $types = array();
  $module_path = drupal_get_path('module', 'plupload');
  $types['plupload'] = array(
    '#input' => TRUE,
    '#attributes' => array('class' => array('plupload-element')),
    '#theme_wrappers' => array('form_element'),
    '#theme' => 'container',
    '#value_callback' => 'plupload_element_value',
    '#attached' => array(
      'library' => array('plupload/plupload'),
      'js' => array($module_path . '/plupload.js'),
      'css' => array($module_path . '/plupload.css'),
    ),
    '#process' => array('plupload_element_process'),
    '#element_validate' => array('plupload_element_validate'),
    '#pre_render' => array('plupload_element_pre_render'),
  );
  return $types;
}

/**
 * Validate callback for plupload form element.
 */
function plupload_element_value(&$element, $input = FALSE, $form_state = NULL) {
  $id = $element['#id'];
  // If a unique identifier added with '--', we need to exclude it
  if(preg_match('/(.*)(--[0-9]+)$/', $id, $reg)) {
    $id = $reg[1];
  }
  $files = array();
  foreach ($form_state['input'] as $key => $value) {
    if (preg_match('/' . $id . '_([0-9]+)_(.*)/', $key, $reg)) {
      $i = $reg[1];
      $key = $reg[2];

      // Only add the keys we expect.
      if (!in_array($key, array('tmpname', 'name', 'status'))) {
        continue;
      }

      // Munge the submitted file names for security.
      //
      // Similar munging is normally done by file_save_upload(), but submit
      // handlers for forms containing plupload elements can't use
      // file_save_upload(), for reasons discussed in plupload_test_submit().
      // So we have to do this for them.
      //
      // Note that we do the munging here in the value callback function
      // (rather than during form validation or elsewhere) because we want to
      // actually modify the submitted values rather than reject them outright;
      // file names that require munging can be innocent and do not necessarily
      // indicate an attempted exploit. Actual validation of the file names is
      // performed later, in plupload_element_validate().
      if (in_array($key, array('tmpname', 'name'))) {
        // Find the whitelist of extensions to use when munging. If there are
        // none, we'll be adding default ones in plupload_element_process(), so
        // use those here.
        if (isset($element['#upload_validators']['file_validate_extensions'][0])) {
          $extensions = $element['#upload_validators']['file_validate_extensions'][0];
        }
        else {
          $validators = _plupload_default_upload_validators();
          $extensions = $validators['file_validate_extensions'][0];
        }
        $value = file_munge_filename($value, $extensions, FALSE);
        // To prevent directory traversal issues, make sure the file name does
        // not contain any directory components in it. (This more properly
        // belongs in the form validation step, but it's simpler to do here so
        // that we don't have to deal with the temporary file names during form
        // validation and can just focus on the final file name.)
        //
        // This step is necessary since this module allows a large amount of
        // flexibility in where its files are placed (for example, they could
        // be intended for public://subdirectory rather than public://, and we
        // don't want an attacker to be able to get them back into the top
        // level of public:// in that case).
        $value = rtrim(drupal_basename($value), '.');


        // Based on the same feture from file_save_upload().
        if (!\Drupal::config('system.file')->get('allow_insecure_uploads') && preg_match('/\.(php|pl|py|cgi|asp|js)(\.|$)/i', $value) && (substr($value, -4) != '.txt')) {
          $value .= '.txt';

          // The .txt extension may not be in the allowed list of extensions.
          // We have to add it here or else the file upload will fail.
          if (!empty($extensions)) {
            $element['#upload_validators']['file_validate_extensions'][0] .= ' txt';
            drupal_set_message(t('For security reasons, your upload has been renamed to %filename.', array('%filename' => $value)));
          }
        }
      }

      // The temporary file name has to be processed further so it matches what
      // was used when the file was written; see plupload_handle_uploads().
      if ($key == 'tmpname') {
        $value = _plupload_fix_temporary_filename($value);
        // We also define an extra key 'tmppath' which is useful so that submit
        // handlers do not need to know which directory plupload stored the
        // temporary files in before trying to copy them.
        $files[$i]['tmppath'] = \Drupal::config('plupload.settings')->get('temporary_uri') . $value;
      }
      elseif ($key == 'name') {
        $value = \Drupal::service('transliteration')->transliterate($value);
      }

      // Store the final value in the array we will return.
      $files[$i][$key] = $value;
    }
  }
  return $files;
}

/**
 * Process callback (#process) for plupload form element.
 */
function plupload_element_process($element) {
  // Start session if not there yet. We need session if we want security
  // tokens to work properly.
  $session_manager = \Drupal::service('session_manager');
  if (!$session_manager->isStarted()) {
    $session_manager->start();
  }

  if (!isset($element['#upload_validators'])) {
    $element['#upload_validators'] = array();
  }
  $element['#upload_validators'] += _plupload_default_upload_validators();
  return $element;
}

/**
 * Element validation handler for a Plupload element.
 */
function plupload_element_validate($element, &$form_state) {
  foreach ($element['#value'] as $file_info) {
    // Here we create a $file object for a file that doesn't exist yet,
    // because saving the file to its destination is done in a submit handler.
    // Using tmp path will give validators access to the actual file on disk and
    // filesize information. We manually modify filename and mime to allow
    // extension checks.
    $destination = \Drupal::config('system.file')->get('default_scheme') . '://' . $file_info['name'];
    $destination = file_stream_wrapper_uri_normalize($destination);
    $file = entity_create('file', array(
      'uri' => $file_info['tmppath'],
      'uid' => \Drupal::currentUser()->id(),
      'status' => FILE_STATUS_PERMANENT,
      'filename' => drupal_basename($destination),
      'filemime' => file_get_mimetype($destination),
    ));

    foreach (file_validate($file, $element['#upload_validators']) as $error_message) {
      $message = t('The specified file %name could not be uploaded.', array('%name' => $file->getFilename()));
      $concatenated_message = $message . ' ' . $error_message;
      \Drupal::formBuilder()->setError($element, $concatenated_message);
    }
  }
}

/**
 * Pre render (#pre_render) callback to attach JS settings for the element.
 */
function plupload_element_pre_render($element) {
  $settings = isset($element['#plupload_settings']) ? $element['#plupload_settings'] : array();

  // Set upload URL.
  if (empty($settings['url'])) {
    $settings['url'] = url(
      'plupload-handle-uploads',
      array(
        'query' => array('token' => \Drupal::csrfToken()->get('plupload-handle-uploads'))
      )
    );
  }

  // The Plupload library supports client-side validation of file extension, so
  // pass along the information for it to do that. However, as with all client-
  // side validation, this is a UI enhancement only, and not a replacement for
  // server-side validation.
  if (empty($settings['filters']) && isset($element['#upload_validators']['file_validate_extensions'][0])) {
    $settings['filters'][] = array(
      // @todo Some runtimes (e.g., flash) require a non-empty title for each
      //   filter, but I don't know what this title is used for. Seems a shame
      //   to hard-code it, but what's a good way to avoid that?
      'title' => t('Allowed files'),
      'extensions' => str_replace(' ', ',', $element['#upload_validators']['file_validate_extensions'][0]),
    );
  }
  // Check for autoupload and autosubmit settings and add appropriate callback.
  if (!empty($element['#autoupload'])) {
    $settings['init']['FilesAdded'] = 'Drupal.plupload.filesAddedCallback';
    if (!empty($element['#autosubmit'])) {
      $settings['init']['UploadComplete'] = 'Drupal.plupload.uploadCompleteCallback';
    }
  }
  // Add a specific submit element that we want to click if one is specified.
  if (!empty($element['#submit_element'])) {
    $settings['submit_element'] = $element['#submit_element'];
  }
  // Check if there are event callbacks and append them to current ones, if any.
  if (!empty($element['#event_callbacks'])) {
    // array_merge() only accepts parameters of type array.
    if (!isset($settings['init'])) {
      $settings['init'] = array();
    }
    $settings['init'] = array_merge($settings['init'], $element['#event_callbacks']);
  }

  if (empty($element['#description'])) {
    $element['#description'] = '';
  }
  $element['#description'] = array(
    '#theme' => 'file_upload_help',
    '#description' => $element['#description'],
    '#upload_validators' => $element['#upload_validators'],
  );

  $element['#attached']['js'][] = array(
    'type' => 'setting',
    'data' => array('plupload' => array($element['#id'] => $settings)),
  );

  return $element;
}

/**
 * Implements hook_library_info_alter().
 *
 * Adds dynamic parts of library definition.
 */
function plupload_library_info_alter(&$library_definition, $extension) {
  if ($extension == 'plupload') {
    $library_definition['plupload']['settings']['plupload']['_default']['max_file_size'] = file_upload_max_size() . 'b';
    $library_definition['plupload']['settings']['plupload']['_default']['chunk_size'] = parse_size(ini_get('post_max_size')) . 'b';

    if (\Drupal::service('module_handler')->moduleExists('locale')) {
      $library_definition['plupload']['js']['js/i18n.js'] = array('scope' => 'footer');
    }
  }
}

/**
 * Fix the temporary filename provided by the plupload library.
 *
 * Newer versions of the plupload JavaScript library upload temporary files
 * with names that contain the intended final prefix of the uploaded file
 * (e.g., ".jpg" or ".png"). Older versions of the plupload library always use
 * ".tmp" as the temporary file extension.
 *
 * We prefer the latter behavior, since although the plupload temporary
 * directory where these files live is always expected to be private (and we
 * protect it via .htaccess; see plupload_handle_uploads()), in case it ever
 * isn't we don't want people to be able to upload files with an arbitrary
 * extension into that directory.
 *
 * This function therefore fixes the plupload temporary filenames so that they
 * will always use a ".tmp" extension.
 *
 * @param string $filename
 *   The original temporary filename provided by the plupload library.
 *
 * @return string
 *   The corrected temporary filename, with a ".tmp" extension replacing the
 *   original one.
 */
function _plupload_fix_temporary_filename($filename) {
  $pos = strpos($filename, '.');
  if ($pos !== FALSE) {
    $filename = substr_replace($filename, '.tmp', $pos);
  }
  return $filename;
}

/**
 * Helper function to add defaults to $element['#upload_validators'].
 */
function _plupload_default_upload_validators() {
  return array(
    // See file_save_upload() for details.
    'file_validate_extensions' => array('jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp'),
  );
}
